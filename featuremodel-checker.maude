load model-checker.maude
load featuremodel.maude

mod FEATUREMODEL-CHECKER is including MODEL-CHECKER + FEATURE-MODEL-TIME . protecting NAT .
  subsort TimeConfiguration < State .
  subsorts Entity < Prop .
  vars    Ent Ent'     : Entity .

  *** Logical operators for entities ***
  op _andalso_               : Entity Entity -> Entity [ctor prec 45] .
  op _orelse_                : Entity Entity -> Entity [ctor prec 49] .
  op neg_                    : Entity        -> Entity [ctor prec 43] .
  op _imp_                   : Entity Entity -> Entity [ctor prec 50] .
  *** Translator functions ***
  op _|-_                    : Configuration Entity -> Bool [prec 51] .

  eq FM(RootFid, [Fid -> F] + FT) # Ops
       |- feature Fid exists = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, g(Gid, GType, Fs) :: Gs, FType)] + FT) # Ops
       |- group Gid exists = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, Gs, FType)] + FT) # Ops
       |- feature Fid has type FType  = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, g(Gid, GType, Fs) :: Gs, FType)] + FT) # Ops
       |- group Gid has type GType = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, g(Gid, GType, Fs) :: Gs, FType)] + FT) # Ops
       |- feature Fid has parent group Gid = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, Gs, FType)] + FT) # Ops
       |- feature Fid has parent ParentFid = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, g(Gid, GType, Fs) :: Gs, FType)] + FT) # Ops
       |- group Gid has parent Fid = true .

  eq FM(RootFid, [Fid -> f(Name, ParentFid, Gs, FType)] + FT) # Ops
       |- feature Fid has name Name = true .

  eq C |- Ent = false [owise] .

  eq currentTime: Time C: C plan: Ps |= Ent  = C |- Ent .

  *** Semantics for logical operators ***
  eq C |- neg Ent          = not C |- Ent                   .
  eq C |- Ent andalso Ent' =     C |- Ent and     C |- Ent' .
  eq C |- Ent orelse  Ent' =     C |- Ent or      C |- Ent' .
  eq C |- Ent imp     Ent' =     C |- Ent implies C |- Ent' .

  op isTime      : TimePoint   -> Prop [ctor] .
  op before      : TimePoint   -> Prop [ctor] . --- exclusive before
  op after       : TimePoint   -> Prop [ctor] . --- exclusive after
  op incl`after_ : TimePoint   -> Prop [ctor] .

  sort Interval .
  op _and_               : TimePoint TimePoint -> Interval [ctor prec 59] .

  op  isTimeImplicit : TimePoint           -> Formula  [ctor]         . --- deals with time points where nothing happens, for example if nothing happens at 4, then everything that is true at 2 is also true at 4
  op _at_            : Entity    TimePoint -> Formula  [ctor prec 60] . --- True if formula is true at last timepoint with registered data
  op _until_         : Entity    TimePoint -> Formula  [ctor prec 60] . --- True if formula is true until first timepoint at or after given timepoint
  op _after_         : Entity    TimePoint -> Formula  [ctor prec 60] .
  op  always_        : Entity              -> Formula  [ctor prec 60] .
  op _while_         : Entity    Entity    -> Formula  [ctor prec 60] .
  op _while`between_ : Entity    Interval  -> Formula  [ctor prec 60] .

  var  C                     : Configuration     .
  var  Model                 : FeatureModel      .
  var  FT                    : FeatureTable      .
  vars Fid ParentFid RootFid : FeatureID         .
  var  FType                 : FeatureType       .
  var  F                     : Feature           .
  var  Fs                    : Features          .
  var  Gs                    : Groups            .
  var  GType                 : GroupType         .
  var  Gid                   : GroupID           .
  var  Name                  : Name              .
  var  Op                    : Operation         .
  var  Ops                   : Operations        .

  var  TC                    : TimeConfiguration .
  vars CT TP TP'             : Nat               .
  var  Time                  : TimePoint         .
  var  Ps                    : Plans             .

  *** State propositions concerning time ***
  eq currentTime: TP C: C plan: Ps
     |= isTime(TP)     = true     .

  eq currentTime: CT C: C plan: Ps
     |= before(TP)     = CT <  TP .

  eq currentTime: CT C: C plan: Ps
     |= after(TP)      = CT >  TP .

  eq currentTime: endTime C: C plan: Ps
     |= after(TP)      = true     .

  eq currentTime: CT C: C plan: Ps
     |= incl after TP  = CT >= TP .

  eq currentTime: endTime C: C plan: Ps
     |= incl after TP  = true     .

  *** Formulas ***
  eq isTimeImplicit(TP) = isTime(TP) \/ (before(TP) /\ O after(TP)) .

  *** User interface ***
  eq Ent at TP = <> (Ent /\ isTimeImplicit(TP)) .

  eq Ent until TP = Ent U incl after TP .

  eq Ent after TP  = [] (after(TP) -> Ent) .

  eq always Ent = [] Ent .

  eq Ent while Ent' = always (Ent' imp Ent) .

  eq Ent while between TP and TP' = <> (isTimeImplicit(TP) /\ (Ent U incl after TP')) .

endm
